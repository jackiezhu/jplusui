/**
 * @fileOverview 模块打包工具。此文件可同时在浏览器或 nodejs 执行。
 * @author xuld
 */

var Utility = Utility || require('./utility');

/**
 * 提供模块打包工具。
 */
var ModuleBuilder = typeof exports === 'object' ? exports : {};

/**
 * 打印日志。
 */
ModuleBuilder.log = Utility.log;

/**
 * 打印错误。
 */
ModuleBuilder.error = Utility.error;

/**
 * 生成开始的回调。
 */
ModuleBuilder.start = function (options) {
    ModuleBuilder.log("正在打包...\n");
};

/**
 * 生成完成的回调。
 */
ModuleBuilder.complete = function (options) {
    ModuleBuilder.log("\n打包成功!");
};

/**
 * 对象默认配置对象。
 */
ModuleBuilder.defaultOptions = {

    // 在每个模块之前插入的注释。
    prependFileComments: '/*********************************************************\n' +
                       ' * This file is created by boot.js at {time}. \n' +
                       ' * DO NOT EDIT IT!!!\n' +
                       ' ********************************************************/',

    // 在每个模块之前插入的注释。
    prependModuleComments: '/*********************************************************\n' +
                             ' * #required {path}\n' +
                             ' ********************************************************/',

    // 生成文件使用的换行符。
    lineBreak: '\r\n',

    // 源文件编码。
    inputEncoding: 'utf-8',

    // 生成文件编码。
    outputEncoding: 'utf-8',
    
    // 默认当前路径。此路径将替换 #require 路径中的 ./ 部分。
    currentPath: '',
    
    // 默认继承路径。此路径将作为 #require 路径的默认基础路径。如果不提供此值，将使用 currentPath 。
    basePath: null,

    // 指示是否生成压缩文件。
    minify: false,

    // 存储要打包的源文件。
    inputs: [],

    // 生成的 JS 路径。
    outputJs: '',

    // 生成的压缩 JS 路径。
    outputMinJs: '',

    // 生成的 CSS 路径。
    outputCss: '',
    
    // 生成的压缩 Css 路径。
    outputMinCss: ''

};

/**
 * 执行打包操作。
 */
ModuleBuilder.build = function (options) {

    options = Utility.extendIf(options || {}, ModuleBuilder.defaultOptions);

    options = Utility.extendIf(options, {

        // 存储最后打包生成的全部 css 文件。
        outputCssList: {},

        // 存储最后打包生成的全部 js 文件。
        outputJsList: {},

        // 存储最后打包生成的全部资源文件。
        outputAssetList: {},

        // 解析过的模块列表。
        parsedModules: {},

        // 被排查的模块路径。
        ignores: [],

        // 解析时预定义的宏。
        defines: {},

    });

    // 修复配置项。

    // 如果未指定生成的 js 和 css 路径，则根据输入文件自动生成。
    if (!options.outputJs && !options.outputCss) {
        var fileName = Utility.getNow().replace(/\D/g, "");
        options.outputJs = fileName + '.js';
        options.outputCss = fileName + '.css';
    }

    // 开始生成操作。
    ModuleBuilder.start(options);

    ModuleBuilder.parseRefs(options, options.inputs, options.currentPath, function () {

        // 排除无效文件。
        for (var i = 0; i < options.ignores.length; i++) {
            var p = options.ignores[i];
            delete options.outputJsList[p];
            delete options.outputCssList[p];
            delete options.outputAssetList[p];
        }

        function generateJsOrCss(jsOrCss) {

            var outputJsOrCss = 'output' + jsOrCss;
            var outputJsOrCssCode = outputJsOrCss + 'Code';

            ModuleBuilder.log('正在生成 ' + (options[outputJsOrCss] || jsOrCss.toLowerCase()));
            options[outputJsOrCssCode] = ModuleBuilder.generateCode(options, options[outputJsOrCss + 'List'], options[outputJsOrCss]);
            if (options[outputJsOrCssCode] === null) {
                return;
            }
            if (options[outputJsOrCss]) {
                Utility.writeFile(options[outputJsOrCss], options[outputJsOrCssCode], options.outputEncoding);
            }
            if (options.minify) {
                var outputJsOrCssMin = options['outputMin' + jsOrCss];
                if (options[outputJsOrCss] && !outputJsOrCssMin) {
                    options['outputMin' + jsOrCss] = outputJsOrCssMin = options[outputJsOrCss].replace(/(\.\w+)$/, '.min$1');
                }

                if (outputJsOrCssMin) {
                    ModuleBuilder.log('正在生成 ' + outputJsOrCssMin);
                } else {
                    ModuleBuilder.log('正在压缩 ' + (options[outputJsOrCss] || jsOrCss.toLowerCase()));
                }
                
                options[outputJsOrCssCode] = Utility['compress' + jsOrCss](options[outputJsOrCssCode]);
                if (outputJsOrCssMin) {
                    Utility.writeFile(outputJsOrCssMin, options[outputJsOrCssCode], options.outputEncoding);
                }
            }

        }

        // 生成 js 和 css 文件。
        generateJsOrCss('Js');
        generateJsOrCss('Css');

        // 复制 assets 路径。
        for (var asset in options.outputAssetList) {
            console.log(asset);
        }

        ModuleBuilder.complete(options);
    });

    return options;

};

/**
 * 解析指定模块列表展开依赖后的全部输出结果。
 * @param {Object} options 相关的配置。
 * @param {Array} modules 所有直接依赖的模块列表。
 * @param {String} currentModulePath 当前模块路径，主要用于解析模块相对路径。
 * @param {Function} callback 所有模块解析完成后的回调函数。
 */
ModuleBuilder.parseRefs = function (options, modules, currentModulePath, callback) {
    var pendingFileCount = modules.length;
    if (pendingFileCount == 0) {
        callback(options);
        return;
    }
    for (var i = 0; i < modules.length; i++) {
        ModuleBuilder.parseRef(options, modules[i], currentModulePath, function () {
            if (--pendingFileCount == 0) {
                callback(options);
            }
        });
    }
};

/**
 * 解析一个模块展开依赖后的全部输出结果。
 * @param {Object} options 相关的配置。
 * @param {Array} modulePath 要解析的模块路径。
 * @param {String} currentModulePath 当前模块路径，主要用于解析模块相对路径。
 * @param {Function} callback 所有模块解析完成后的回调函数。
 */
ModuleBuilder.parseRef = function (options, modulePath, currentModulePath, callback) {

    var fullPath = Utility.resolveRelativePath(currentModulePath, modulePath, options.basePath);

    // 不重复解析同一个模块。
    var parsedModule = options.parsedModules[fullPath];
    if (parsedModule) {
        callback(options);
        return;
    }

    // 开始处理指定文件。
    options.startParseModule && options.startParseModule(fullPath);

    switch (Utility.getExtension(fullPath)) {
        case '.js':
        case '.coffee':
        case '.ts':
        case '.dart':
            parsedModule = 'js';
            ModuleBuilder.parseJsRef(options, fullPath, callback);
            break;
        case '.css':
        case '.less':
        case '.sass':
        case '.stuye':
            parsedModule = 'css';
            ModuleBuilder.parseCssRef(options, fullPath, callback);
            break;
        case '':
            parsedModule = 'all';
            ModuleBuilder.parseRefs(options, [modulePath + '.css', modulePath + '.js'], currentModulePath, callback);
            break;
        default:
            parsedModule = 'none';
            break;
    }

    // 标记模块已解析。
    options.parsedModules[fullPath] = parsedModule;

};

/**
 * 解析一个模块展开依赖后的全部输出结果。
 * @param {Object} options 相关的配置。
 * @param {Array} modulePath 要解析的模块路径。
 * @param {Function} callback 所有模块解析完成后的回调函数。
 */
ModuleBuilder.parseJsRef = function (options, modulePath, callback) {

    Utility.readFile(modulePath, function (content) {

        // 解析 #if 等。
        content = Utility.resolveMacro(content, options.defines);

        var refs = [];

        // 解析 #require。
        content = ModuleBuilder.resolveRequire(content, modulePath, options.basePath, refs, options.ignores);

        // 解析依赖项。
        ModuleBuilder.parseRefs(options, refs, modulePath, function () {

            // 保存生成结果。
            options.outputJsList[modulePath] = content;

            // 执行回调。
            callback();

        });

    }, ModuleBuilder.error, options.inputEncoding);

};

/**
 * 解析一个模块展开依赖后的全部输出结果。
 * @param {Object} options 相关的配置。
 * @param {Array} modulePath 要解析的模块路径。
 * @param {Function} callback 所有模块解析完成后的回调函数。
 */
ModuleBuilder.parseCssRef = function (options, modulePath, callback) {

    Utility.readFile(modulePath, function (content) {

        // 解析 #if 等。
        content = Utility.resolveMacro(content, options.defines);

        var refs = [];

        // 解析 #require。
        content = ModuleBuilder.resolveRequire(content, modulePath, options.basePath, refs, options.ignores);

        // 解析 @import。
        content = content.replace(/(@import\s+)?(url\s*\(\s*(['"]?))(.+)(\3\s*\))/ig, function (all, isImport, q1, _, imgUrl, q2) {

            // 不处理绝对路径。
            if (imgUrl.indexOf(':') >= 0) {
                return all;
            }

            // 导入外部 CSS。
            if (isImport) {
                refs.push('./' + imgUrl);
                return '/*' + all + '*/';
            }

            // 源图片的原始物理路径。
            var fullPath = Utility.resolveRelativePath(modulePath, imgUrl);

            options.outputAssetList[fullPath] = imgUrl;

            return all;
        });

        ModuleBuilder.parseRefs(options, refs, modulePath, function () {

            // 保存生成结果。
            options.outputCssList[modulePath] = content;

            // 执行回调。
            callback();

        });

    }, ModuleBuilder.error, options.inputEncoding);

};

/**
 * 解析 #require。
 */
ModuleBuilder.resolveRequire = function (content, path, basePath, refs, ignores) {
    return content.replace(/^(\s*\/[\/\*]\s*#)(\w+)\s+([^\r\n\*]+)/gm, function (all, prefix, macro, args) {
        switch (macro) {
            case 'require':
                refs.push(args);
                return all.replace('#', '!');
            case 'required':
                var p = Utility.resolveRelativePath(path, args, basePath);
                if (ignores.indexOf(p) < 0) {
                    ignores.push(p);
                }
                break;
        }
        return all;
    });
};

/**
 * 根据返回的依赖列表生成最终源码。
 * @param {Object} options 相关的配置。
 * @param {Array} outputList 生成的依赖列表。
 */
ModuleBuilder.generateCode = function (options, outputList, savePath) {

    var content = '', hasItems;

    // 添加注释。
    if (options.prependFileComments) {
        content += options.prependFileComments
            .replace('{time}', Utility.getNow())
            .replace(/\r?\n/g, options.lineBreak) + options.lineBreak;
    }

    for (var p in outputList) {

        hasItems = true;

        // 添加注释。
        if (options.prependModuleComments) {
            content += options.lineBreak + options.lineBreak + options.prependModuleComments
                .replace('{time}', Utility.getNow())
                .replace('{path}', Utility.getRelativePath(savePath, p))
                .replace(/\r?\n/g, options.lineBreak);
        }

        content += options.lineBreak;

        content += outputList[p];
    }

    return hasItems ? content : null;
};
