/**
 * @fileOverview 模块打包工具。此文件可同时在浏览器或 nodejs 执行。
 * @author xuld
 */

var Utility = Utility || require('./utility');

/**
 * 提供模块打包工具。
 */
var ModuleBuilder = typeof exports === 'object' ? exports : {};

/**
 * 打印日志。
 */
ModuleBuilder.log = function (message) {
    if (typeof console !== 'undefined' && console.log) {
        console.log(message);
    }
};

/**
 * 打印错误。
 */
ModuleBuilder.error = function (message) {
    if (typeof console !== 'undefined' && console.error) {
        console.error(message);
    } else {
        ModuleBuilder.log(message);
    }
};

/**
 * 生成开始的回调。
 */
ModuleBuilder.start = function (options) {
    ModuleBuilder.log("正在打包...");
};

/**
 * 生成完成的回调。
 */
ModuleBuilder.complete = function (options) {
    ModuleBuilder.log("打包成功!");
};

/**
 * 对象默认配置对象。
 */
ModuleBuilder.defaultOptions = {

    // 常量配置。

    // 在每个模块之前插入的注释。
    prependFileComments: '/*********************************************************\n' +
                       ' * This file is created by boot.js at {time}. \n' +
                       ' * DO NOT EDIT IT!!!\n' +
                       ' ********************************************************/\n',

    // 在每个模块之前插入的注释。
    prependModuleComments: '/*********************************************************\n' +
                             ' * {path}\n' +
                             ' ********************************************************/',

    // 生成文件使用的换行符。
    lineBreak: '\r\n',

    // 源文件编码。
    inputEncoding: 'utf-8',

    // 生成文件编码。
    outputEncoding: 'utf-8',

    // 用户指定配置。

    // 存储要打包的源文件。
    inputs: [],

    // 解析时预定义的宏。
    defines: {},

    // 指示是否生成压缩文件。
    minify: false,

    // 生成的 JS 路径。
    outputJs: '',

    // 生成的 CSS 路径。
    outputCss: '',

    // 默认继承路径。#require 将使用此为基础路径。
    basePath: '',

    // 默认当前路径。#require 将使用此为默认相对路径。
    currentPath: ''

};

/**
 * 解析宏。
 */
ModuleBuilder.resolveMacro = function (content, defines) {

    var m = /^\/\/\/\s*#(\w+)(.*?)$/m;

    var r = [];

    while (content) {
        var value = m.exec(content);

        if (!value) {
            r.push([content, 0, 0]);
            break;
        }

        // 保留匹配部分的左边字符串。
        r.push([content.substring(0, value.index), 0, 0]);

        r.push(value);

        // 截取匹配部分的右边字符串。
        content = content.substring(value.index + value[0].length);
    }

    var codes = ['var $out="",$t;'];

    r.forEach(function (value, index) {

        if (!value[1]) {
            codes.push('$out+=$r[' + index + '][0];');
            return;
        }

        var v = value[2].trim();

        switch (value[1]) {

            case 'if':
                codes.push('if(' + v.replace(/\b([a-z_$]+)\b/ig, "$d.$1") + '){');
                break;

            case 'else':
                codes.push('}else{');
                break;

            case 'elsif':
                codes.push('}else if(' + v.replace(/\b([a-z_$]+)\b/g, "$d.$1") + '){');
                break;

            case 'endif':
            case 'endregion':
                codes.push('}');
                break;

            case 'define':
                var space = v.search(/\s/);
                if (space === -1) {
                    codes.push('if(!(' + v + ' in $d))$d.' + v + "=true;");
                } else {
                    codes.push('$d.' + v.substr(0, space) + "=" + v.substr(space) + ";");
                }
                break;

            case 'undef':
                codes.push('delete $d.' + v + ";");
                break;

            case 'ifdef':
                codes.push('if(' + v + ' in $d){');
                break;

            case 'ifndef':
                codes.push('if(!(' + v + ' in $d)){');
                break;

            case 'region':
                codes.push('if($d.' + v + ' !== false){');
                break;

            case 'rem':
                break;

            default:
                codes.push('$out+=$r[' + index + '][0];');
                break;
        }

    });

    codes.push('return $out;');

    var fn = new Function("$r", "$d", codes.join(''));

    return fn(r, defines);
};

/**
 * 解析 #require。
 */
ModuleBuilder.resolveRequire = function (content, path, basePath, refs, ignores) {
    return content.replace(/^(\s*)\/[\/\*]\s*#(\w+)\s+([^\r\n\*]+)/gm, function (all, indent, macro, args) {
        switch (macro) {
            case 'require':
                refs.push(args);
                return all.replace('require', 'required');
            case 'required':
                var path = Utility.resolveRelativePath(path, args, basePath);
                if (ignores.indexOf(path) < 0) {
                    ignores.push(path);
                }
                break;
        }
        return all;
    });
};

/**
 * 执行打包操作。
 */
ModuleBuilder.build = function (options) {

    options = Utility.extendIf(options || {}, ModuleBuilder.defaultOptions);

    options = Utility.extendIf(options, {

        // 存储最后打包生成的全部 css 文件。
        outputCssList: {},

        // 存储最后打包生成的全部 js 文件。
        outputJsList: {},

        // 存储最后打包生成的全部资源文件。
        outputAssetList: {},

        // 解析过的模块列表。
        parsedModules: {},

        // 被排查的模块路径。
        ignores: [],

    });

    // 修复配置项。

    // 如果未指定生成的 js 和 css 路径，则根据输入文件自动生成。
    if (!options.outputJs && !options.outputCss) {
        var fileName = Utility.getNow().replace(/\D/g, "");
        options.outputJs = fileName + '.js';
        options.outputCss = fileName + '.css';
    }

    // 开始生成操作。
    ModuleBuilder.start(options);

    ModuleBuilder.parseRefs(options, options.inputs, options.currentPath, function () {

        // 排除无效文件。
        for (var i = 0; i < options.ignores.length; i++) {
            var p = options.ignores[i];
            delete options.outputJsList[p];
            delete options.outputCssList[p];
            delete options.outputAssetList[p];
        }

        function generateJsOrCss(jsOrCss) {

            var outputJsOrCss = 'output' + jsOrCss;
            var outputJsOrCssCode = outputJsOrCss + 'Code';

            ModuleBuilder.log('正在生成 ' + (options[outputJsOrCss] || jsOrCss.toLowerCase()));
            options[outputJsOrCssCode] = ModuleBuilder.generateOutput(options, options[outputJsOrCss + 'List']);
            if (options[outputJsOrCssCode] === null) {
                return;
            }
            if (options[outputJsOrCss]) {
                Utility.writeFile(options[outputJsOrCss], options[outputJsOrCssCode], options.outputEncoding);
            }
            if (options.minify) {
                var p;
                if (options[outputJsOrCss]) {
                    p = options[outputJsOrCss].replace(/(\.\w+)$/, '.min$1');
                    ModuleBuilder.log('正在生成 ' + p);
                }
                options[outputJsOrCssCode] = Utility['compress' + jsOrCss](options[outputJsOrCssCode]);
                if (options[outputJsOrCss]) {
                    Utility.writeFile(p, options[outputJsOrCssCode], options.outputEncoding);
                }
            }

        }

        // 生成 js 和 css 文件。
        generateJsOrCss('Js');
        generateJsOrCss('Css');

        // 复制 assets 路径。
        for (var asset in options.outputAssetList) {
            console.log(asset);
        }

        ModuleBuilder.complete(options);
    });

    return options;

};

/**
 * 解析指定模块列表展开依赖后的全部输出结果。
 * @param {Object} options 相关的配置。
 * @param {Array} modules 所有直接依赖的模块列表。
 * @param {String} currentModulePath 当前模块路径，主要用于解析模块相对路径。
 * @param {Function} callback 所有模块解析完成后的回调函数。
 */
ModuleBuilder.parseRefs = function (options, modules, currentModulePath, callback) {
    var pendingFileCount = modules.length;
    if (pendingFileCount == 0) {
        callback(options);
        return;
    }
    for (var i = 0; i < modules.length; i++) {
        ModuleBuilder.parseRef(options, modules[i], currentModulePath, function () {
            if (--pendingFileCount == 0) {
                callback(options);
            }
        });
    }
};

/**
 * 解析一个模块展开依赖后的全部输出结果。
 * @param {Object} options 相关的配置。
 * @param {Array} modulePath 要解析的模块路径。
 * @param {String} currentModulePath 当前模块路径，主要用于解析模块相对路径。
 * @param {Function} callback 所有模块解析完成后的回调函数。
 */
ModuleBuilder.parseRef = function (options, modulePath, currentModulePath, callback) {

    var fullPath = Utility.resolveRelativePath(currentModulePath, modulePath, options.basePath);

    // 不重复解析同一个模块。
    var parsedModule = options.parsedModules[fullPath];
    if (parsedModule) {
        callback(options);
        return;
    }

    // 开始处理指定文件。
    options.startParseModule && options.startParseModule(fullPath);

    switch (Utility.Path.extname(fullPath)) {
        case '.js':
        case '.coffee':
        case '.ts':
        case '.dart':
            parsedModule = 'js';
            ModuleBuilder.parseJsRef(options, fullPath, callback);
            break;
        case '.css':
        case '.less':
        case '.sass':
        case '.stuye':
            parsedModule = 'css';
            ModuleBuilder.parseCssRef(options, fullPath, callback);
            break;
        case '':
            parsedModule = 'all';
            ModuleBuilder.parseRefs(options, [modulePath + '.css', modulePath + '.js'], currentModulePath, callback);
            break;
        default:
            parsedModule = 'none';
            break;
    }

    // 标记模块已解析。
    options.parsedModules[fullPath] = parsedModule;

};

/**
 * 解析一个模块展开依赖后的全部输出结果。
 * @param {Object} options 相关的配置。
 * @param {Array} modulePath 要解析的模块路径。
 * @param {Function} callback 所有模块解析完成后的回调函数。
 */
ModuleBuilder.parseJsRef = function (options, modulePath, callback) {

    Utility.readFile(modulePath, function (content) {

        // 解析 #if 等。
        content = ModuleBuilder.resolveMacro(content, options.defines);

        var refs = [];

        // 解析 #require。
        content = ModuleBuilder.resolveRequire(content, modulePath, options.basePath, refs, options.ignores);

        // 解析依赖项。
        ModuleBuilder.parseRefs(options, refs, modulePath, function () {

            // 保存生成结果。
            options.outputJsList[modulePath] = content;

            // 执行回调。
            callback();

        });

    }, ModuleBuilder.error, options.inputEncoding);

};

/**
 * 解析一个模块展开依赖后的全部输出结果。
 * @param {Object} options 相关的配置。
 * @param {Array} modulePath 要解析的模块路径。
 * @param {Function} callback 所有模块解析完成后的回调函数。
 */
ModuleBuilder.parseCssRef = function (options, modulePath, callback) {

    Utility.readFile(modulePath, function (content) {

        // 解析 #if 等。
        content = ModuleBuilder.resolveMacro(content, options.defines);

        var refs = [];

        // 解析 #require。
        content = ModuleBuilder.resolveRequire(content, modulePath, options.basePath, refs, options.ignores);

        // 解析 @import。
        content = content.replace(/(@import\s+)?(url\s*\(\s*(['"]?))(.+)(\3\s*\))/ig, function (all, isImport, q1, _, imgUrl, q2) {

            // 不处理绝对路径。
            if (imgUrl.indexOf(':') >= 0) {
                return all;
            }

            // 导入外部 CSS。
            if (isImport) {
                refs.push('./' + imgUrl);
                return '/*' + all + '*/';
            }

            // 源图片的原始物理路径。
            var fullPath = Utility.resolveRelativePath(modulePath, imgUrl);

            options.outputAssetList[fullPath] = imgUrl;

            return all;
        });

        ModuleBuilder.parseRefs(options, refs, modulePath, function () {

            // 保存生成结果。
            options.outputCssList[modulePath] = content;

            // 执行回调。
            callback();

        });

    }, ModuleBuilder.error, options.inputEncoding);

};

/**
 * 根据返回的依赖列表生成最终源码。
 * @param {Object} options 相关的配置。
 * @param {Array} outputList 生成的依赖列表。
 */
ModuleBuilder.generateOutput = function (options, outputList) {

    var content = null;

    // 添加注释。
    if (options.prependFileComments) {
        content += options.prependFileComments
            .replace('{time}', Utility.getNow())
            .replace(/\r?\n/g, options.lineBreak) + options.lineBreak;
    }

    for (var p in outputList) {

        // 添加注释。
        if (options.prependModuleComments) {
            content += options.lineBreak + options.lineBreak + options.prependModuleComments
                .replace('{time}', Utility.getNow())
                .replace('{path}', p)
                .replace(/\r?\n/g, options.lineBreak);
        }

        content += options.lineBreak;

        content += outputList[p];
    }

    return content;
};
