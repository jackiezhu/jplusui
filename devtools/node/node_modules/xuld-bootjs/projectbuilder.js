/**
 * @fileOverview 模块打包工具。此文件可同时在浏览器或 nodejs 执行。
 * @author xuld
 */
// #region Path
/**
 * 路径处理模块。
 */var Path = typeof exports === 'object' ? require('path') : {

    // resolves . and .. elements in a path array with directory names there
    // must be no slashes, empty elements, or device names (c:\) in the array
    // (so also no leading and trailing slashes - it does not distinguish
    // relative and absolute paths)
    _normalizeArray: function (parts, allowAboveRoot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
            var last = parts[i];
            if (last === '.') {
                parts.splice(i, 1);
            } else if (last === '..') {
                parts.splice(i, 1);
                up++;
            } else if (up) {
                parts.splice(i, 1);
                up--;
            }
        }

        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
            for (; up--; up) {
                parts.unshift('..');
            }
        }

        return parts;
    },

    // Split a filename into [root, dir, basename, ext], unix version
    // 'root' is just a slash, or nothing.
    _splitPath: function (filename) {
        return /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(filename).slice(1);
    },

    basePath: "",

    resolve: function () {
        var resolvedPath = '',
			resolvedAbsolute = false;

        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path = (i >= 0) ? arguments[i] : Path.basePath;

            // Skip empty and invalid entries
            if (typeof path !== 'string') {
                throw new TypeError('Arguments to path.resolve must be strings');
            } else if (!path) {
                continue;
            }

            resolvedPath = path + '/' + resolvedPath;
            resolvedAbsolute = path.charAt(0) === '/';
        }

        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)

        // Normalize the path
        resolvedPath = Path._normalizeArray(resolvedPath.split('/').filter(function (p) {
            return !!p;
        }), !resolvedAbsolute).join('/');

        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
    },

    normalize: function (path) {

        var isAbsolute = path.charAt(0) === '/',
			trailingSlash = path.substr(-1) === '/';

        // Normalize the path
        path = Path._normalizeArray(path.split('/').filter(function (p) {
            return !!p;
        }), !isAbsolute).join('/');

        if (!path && !isAbsolute) {
            path = '.';
        }
        if (path && trailingSlash) {
            path += '/';
        }

        return (isAbsolute ? '/' : '') + path.replace(/^(?:(\w{2,}:\/))([^\/])/, '$1/');
    },

    join: function () {
        var paths = Array.prototype.slice.call(arguments, 0);
        return Path.normalize(paths.filter(function (p, index) {
            if (typeof p !== 'string') {
                throw new TypeError('Arguments to path.join must be strings');
            }
            return p;
        }).join('/'));
    },

    relative: function (from, to) {

        from = Path.resolve(from);
        to = Path.resolve(to);

        function trim(arr) {
            var start = 0;
            for (; start < arr.length; start++) {
                if (arr[start] !== '') break;
            }

            var end = arr.length - 1;
            for (; end >= 0; end--) {
                if (arr[end] !== '') break;
            }

            if (start > end) return [];
            return arr.slice(start, end - start + 1);
        }

        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));

        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
            if (fromParts[i] !== toParts[i]) {
                samePartsLength = i;
                break;
            }
        }

        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
            outputParts.push('..');
        }

        outputParts.push.apply(outputParts, toParts.slice(samePartsLength));

        return outputParts.join('/');
    },

    dirname: function (path) {
        var result = Path._splitPath(path),
			root = result[0],
			dir = result[1];

        if (!root && !dir) {
            // No dirname whatsoever
            return '.';
        }

        if (dir) {
            // It has a dirname, strip trailing slash
            dir = dir.substr(0, dir.length - 1);
        }

        return root + dir;
    },

    basename: function (path, ext) {
        var f = Path._splitPath(path)[2];
        // TODO: make this comparison case-insensitive on windows?
        if (ext && f.substr(-1 * ext.length) === ext) {
            f = f.substr(0, f.length - ext.length);
        }
        return f;
    },

    extname: function (path) {
        return Path._splitPath(path)[3];
    }

};

// #endregion

/**
 * 提供模块打包工具。
 */
var ModuleBuilder = typeof exports === 'object' ? exports : {};

/**
 * 打印日志。
 */
ModuleBuilder.log = function (message) {
    if (typeof console !== 'undefined' && console.log) {
        console.log(message);
    }
};

/**
 * 打印错误。
 */
ModuleBuilder.error = function (message) {
    if (typeof console !== 'undefined' && console.error) {
        console.error(message);
    } else {
        ModuleBuilder.log(message);
    }
};

/**
 * 生成开始的回调。
 */
ModuleBuilder.start = function (buildContext) {
    ModuleBuilder.log("正在打包...");
};

/**
 * 生成完成的回调。
 */
ModuleBuilder.complete = function (buildContext) {
    ModuleBuilder.log("打包成功!");
};

/**
 * 解析相对路径。
 */
ModuleBuilder.resolvePath = function (basePath, relativePath) {
    var protocol = /^\w+:\/\/[^\\]*?(\/|$)/.exec(basePath);
    if (protocol) {
        basePath = basePath.substr(protocol[0].length);
    }
    basePath = Path.resolve(Path.dirname(basePath), relativePath).replace(/\\/g, "/");
    return Path.normalize(protocol ? protocol[0] + basePath : basePath);
};

/**
 * 读取文件内容。
 */
ModuleBuilder.readFile = typeof exports === "object" ? function (filePath, success, error, encoding) {
    require("fs").readFile(filePath, encoding || "utf-8", function (error, content) {
        if (error) {
            error && error(error.message);
        } else {
            success && success(content.replace(/^\uFEFF/, ''));
        }
    });
} : function (filePath, success, error) {
    var xhr = new XMLHttpRequest();
    xhr.open('get', filePath, true);
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
            xhr.onreadystatechange = null;
            var status = xhr.status;
            if ((status >= 200 && status < 300) || status == 304 || status == 1223) {
                success && success(xhr.responseText);
            } else {
                error && error(xhr.status + '-' + xhr.statusText);
            }
        }
    };
    xhr.send(null);
};

/**
 * 写入文件。
 */
ModuleBuilder.writeFile = typeof exports === "object" ? function (filePath, content) {
    require("utilskit/io").writeFile(filePath, content, "utf-8");
} : function (filePath, content) {
    var dom = document.createElement('textarea');
    dom.title = filePath;
    dom.value = content;
    document.body.appendChild(dom);
};

/**
 * 复制文件。
 */
ModuleBuilder.copyFile = typeof exports === "object" ? function (fromPath, toPath) {
    require("utilskit/io").copyFile(fromPath, toPath);
} : function (fromPath, toPath) {
    console.log('复制文件：' + fromPath + ' 到 ' + toPath);
};

/**
 * 执行打包操作。
 */
ModuleBuilder.build = function (options) {

    // 生成新的上下文对象。
    var buildContext = {

        // 常量配置。

        // 在每个模块之前插入的注释。
        prependFileComments: '/*********************************************************\n' +
                           ' * This file is created by boot.js at {time}. DO NOT EDIT IT!!!\n' +
                           ' ********************************************************/\n',

        // 在每个模块之前插入的注释。
        prependModuleComments: '/*********************************************************\n' +
                                 ' * {path}\n' +
                                 ' ********************************************************/',

        // 生成文件使用的换行符。
        lineBreak: '\r\n',

        // 源文件编码。
        inputEncoding: 'utf-8',

        // 生成文件编码。
        outputEncoding: 'utf-8',

        // 用户指定配置。

        // 存储要打包的源文件。
        inputs: [],

        // 解析时预定义的宏。
        defines: {},

        // 生成的 CSS 路径中引用图片的相对路径。
        relativeAssetsUrl: '',

        // 生成的 CSS 路径。
        outputCss: {},

        // 生成的 JS 路径。
        outputJs: {},

        // 生成的资源文件夹路径。
        outputAssets: {},

        // 指示是否生成压缩文件。
        minify: false,

        // 被排查的模块路径。
        excluded: [],

        // 输出。

        // 存储最后打包生成的全部 css 文件。
        outputCssContents: {},

        // 存储最后打包生成的全部 js 文件。
        outputJsContents: {},

        // 存储最后打包生成的全部资源文件。
        outputAssetContents: {}

    };

    // 复制用户提供的配置项。
    for (var key in options) {
        buildContext[key] = options[key];
    }

    // 修复配置项。

    // 指示剩下正在处理的文件数。
    buildContext.pendingFileCount = 0;

    // 如果未指定生成的 js 和 css 路径，则根据输入文件自动生成。
    if (!buildContext.outputJs && !buildContext.outputCss && buildContext.inputs[0] && /\.boot\.js$/.test(buildContext.inputs[0])) {
        buildContext.outputJs = buildContext.inputs[0].replace(/\.boot\.js$/, '.js');
        buildContext.outputCss = buildContext.inputs[0].replace(/\.boot\.js$/, '.css');
    }

    //if (!buildContext.file.relativeImages && buildContext.file.css && buildContext.file.assets) {
    //    buildContext.file.relativeImages = Path.relative(Path.dirname(buildContext.file.css), buildContext.file.assets).replace(/\\/g, '/');
    //}

    // 开始生成操作。
    ModuleBuilder.start(buildContext);

    if (!buildContext.inputs.length) {
        onSuccess();
        return;
    }

    // 执行生成操作。
    for (var i = 0; i < buildContext.inputs.length; i++) {
        ModuleBuilder.parseModule(buildContext, Path.normalize(buildContext.inputs[i]), function () {
            if (--buildContext.pendingFileCount == 0) {
                onSuccess();
            }
        });
    }

    // 全部模块处理完成。
    function onSuccess() {

        // 排除无效文件。
        for (var i = 0; i < buildContext.excluded.length; i++) {
            var p = Path.normalize(buildContext.excluded[i]);
            delete buildContext.outputCssContents[p];
            delete buildContext.outputJsContents[p];
            delete buildContext.outputAssetContents[p];
        }

        // 生成文件。
        ModuleBuilder._generateFile(buildContext, buildContext.outputJs, buildContext.outputJsContents, 'outpurJsSource', ModuleBuilder.compressJs);
        ModuleBuilder._generateFile(buildContext, buildContext.outputCss, buildContext.outputCssContents, 'outpurCssSource', ModuleBuilder.compressCss);

        ModuleBuilder.complete(buildContext);
    }

    return buildContext;

};

ModuleBuilder._parsedModules = {};

/**
 * 解析一个模块。
 */
ModuleBuilder.parseModule = function (buildContext, modulePath, callback) {

    // 不重复解析同一个模块。
    var parsedModule = ModuleBuilder._parsedModules[modulePath];
    if (parsedModule) {
        return;
    }

    // 开始处理指定文件。
    buildContext.pendingFileCount++;
    ModuleBuilder.log("正在分析 " + modulePath + " ...");

    switch (Path.extname(modulePath)) {
        case '.js':
        case '.coffee':
        case '.ts':
        case '.dart':
            parsedModule = 'js';
            ModuleBuilder.parseJsModule(buildContext, modulePath, callback);
            break;
        case '.css':
        case '.less':
        case '.sass':
        case '.stuye':
            parsedModule = 'css';
            ModuleBuilder.parseCssModule(buildContext, modulePath, callback);
            break;
        case '':
            buildContext.pendingFileCount++;
            parsedModule = 'all';
            ModuleBuilder.parseCssModule(buildContext, modulePath + '.css', callback);
            ModuleBuilder.parseJsModule(buildContext, modulePath + '.js', callback);
            break;
        default:
            parsedModule = 'asset';
            ModuleBuilder.parseAssetsModule(buildContext, modulePath, callback);
            break;
    }

    // 标记模块已解析。
    ModuleBuilder._parsedModules[modulePath] = parsedModule;

};

ModuleBuilder.parseJsModule = function (buildContext, modulePath, success, error) {

};

ModuleBuilder.parseCssModule = function (buildContext, modulePath, callback) {

    ModuleBuilder.readFile(modulePath, function (content) {

        // 解析 #if 等。
        content = ModuleBuilder.resolveMacro(content, buildContext.defines);

        // 解析 #require。
        content = ModuleBuilder.resolveRequire(content, modulePath, buildContext, callback);

        // 解析 @import。
        content = content.replace(/(@import\s+)?(url\s*\(\s*(['"]?))(.+)(\3\s*\))/ig, function (all, isImport, q1, _, imgUrl, q2) {

            // 不处理绝对路径。
            if (imgUrl.indexOf(':') >= 0) {
                return all;
            }

            // 导入外部 CSS。
            if (isImport) {
                ModuleBuilder.parseModule(buildContext, imgUrl, modulePath, callback);
                return '/*' + all + '*/';
            }

            // 源图片的原始物理路径。
            var newPath = ModuleBuilder.parseAssetsModule(buildContext, ModuleBuilder.resolvePath(modulePath, imgUrl), callback);
            if (newPath) {
                return q1 + asset.relative + q2;
            }

            return all;
        });

        // 保存生成结果。
        buildContext.outputCssContents[modulePath] = content;

        // 执行回调。
        callback(buildContext);

    }, ModuleBuilder.error, buildContext.inputEncoding);

};

/**
 * 解析一个普通资源模块。
 */
ModuleBuilder.parseAssetsModule = function (buildContext, modulePath, callback) {
    

    //var assets = 


};

/**
 * 输出最后生成的 js 文件。
 */
ModuleBuilder.copyAssets = function (content, modulePath, newPath, buildContext) {
    buildContext.outputAssets[modulePath] = newPath;
};

/**
 * 解析宏。
 */
ModuleBuilder.resolveMacro = function (content, defines) {

    var m = /^\/\/\/\s*#(\w+)(.*?)$/m;

    var r = [];

    while (content) {
        var value = m.exec(content);

        if (!value) {
            r.push([content, 0, 0]);
            break;
        }

        // 保留匹配部分的左边字符串。
        r.push([content.substring(0, value.index), 0, 0]);

        r.push(value);

        // 截取匹配部分的右边字符串。
        content = content.substring(value.index + value[0].length);
    }

    var codes = ['var $out="",$t;'];

    r.forEach(function (value, index) {

        if (!value[1]) {
            codes.push('$out+=$r[' + index + '][0];');
            return;
        }

        var v = value[2].trim();

        switch (value[1]) {

            case 'if':
                codes.push('if(' + v.replace(/\b([a-z_$]+)\b/ig, "$d.$1") + '){');
                break;

            case 'else':
                codes.push('}else{');
                break;

            case 'elsif':
                codes.push('}else if(' + v.replace(/\b([a-z_$]+)\b/g, "$d.$1") + '){');
                break;

            case 'endif':
            case 'endregion':
                codes.push('}');
                break;

            case 'define':
                var space = v.search(/\s/);
                if (space === -1) {
                    codes.push('if(!(' + v + ' in $d))$d.' + v + "=true;");
                } else {
                    codes.push('$d.' + v.substr(0, space) + "=" + v.substr(space) + ";");
                }
                break;

            case 'undef':
                codes.push('delete $d.' + v + ";");
                break;

            case 'ifdef':
                codes.push('if(' + v + ' in $d){');
                break;

            case 'ifndef':
                codes.push('if(!(' + v + ' in $d)){');
                break;

            case 'region':
                codes.push('if($d.' + v + ' !== false){');
                break;

            case 'rem':
                break;

            default:
                codes.push('$out+=$r[' + index + '][0];');
                break;
        }

    });

    codes.push('return $out;');

    var fn = new Function("$r", "$d", codes.join(''));

    return fn(r, defines);
};

/**
 * 解析 #require。
 */
ModuleBuilder.resolveRequire = function (content, basePath, buildContext, callback) {
    return content.replace(/^(\s*)\/[\/\*]\s*#(\w+)\s+([^\r\n\*]+)/gm, function (all, indent, macro, args) {
        switch (macro) {
            case 'require':
                ModuleBuilder.parseModule(buildContext, ModuleBuilder.resolvePath(basePath, args), callback);
                return all.replace('require', 'required');
            case 'required':
                buildContext.excludes.push(ModuleBuilder.resolvePath(basePath, args));
                break;
        }
        return all;
    });
};

/**
 * 生成 js 和 css 文件。
 */
ModuleBuilder._generateFile = function (buildContext, outputContentPath, outputContents, outputFieldName, compressor) {

    ModuleBuilder.log("正在生成 " + outputContentPath);

    var content = '';

    // 添加注释。
    if (buildContext.prependFileComments) {
        content += buildContext.prependFileComments
            .replace('{time}', ModuleBuilder._getNow())
            .replace(/\r?\n/g, buildContext.lineBreak) + buildContext.lineBreak;
    }

    for (var p in outputContents) {

        // 添加注释。
        if (buildContext.prependModuleComments) {
            content += buildContext.prependModuleComments
                .replace('{time}', ModuleBuilder._getNow())
                .replace('{path}', p)
                .replace(/\r?\n/g, buildContext.lineBreak);
        }

        content += buildContext.lineBreak;

        content += outputContents[p];
    }

    buildContext[outputFieldName] = content;

    if (outputContentPath) {
        ModuleBuilder.writeFile(outputContentPath, content, buildContext.outputEncoding);
    }

    if (buildContext.minify) {
        var minPath = outputContentPath.replace(/(\.\w*$)/, '.min$1');
        ModuleBuilder.log("正在生成 " + minPath);

        // 执行压缩。
        content = compressor(content);

        ModuleBuilder.writeFile(minPath, content, buildContext.outputEncoding);

    }

};

ModuleBuilder._getNow = function () {
    var d = new Date();
    d = [d.getFullYear(), '/', d.getMonth() + 1, '/', d.getDate(), ' ', d.getHours(), ':', d.getMinutes()];

    if (d[d.length - 1] < 10) {
        d[d.length - 1] = '0' + d[d.length - 1];
    }

    if (d[d.length - 3] < 10) {
        d[d.length - 3] = '0' + d[d.length - 3];
    }

    return d.join('');
};

/**
 * 压缩 js。
 */
ModuleBuilder.compressJs = function (code) {

    if (typeof Compressor !== "function" || typeof parse !== "function") {
        if (typeof exports !== "object") {
            return code;
        }
        parse = require('uglify-js').parse;
        Compressor = require('uglify-js').Compressor;
    }

    var ast = parse(value);
    ast.figure_out_scope();
    // https://github.com/mishoo/UglifyJS2#compressor-options

    var compressor = Compressor();

    compressor.options.warnings = false;

    ast.transform(compressor);
    ast.figure_out_scope();
    ast.compute_char_frequency();
    ast.mangle_names();
    return ast.print_to_string();
};

/**
 * 压缩 css。
 */
ModuleBuilder.compressCss = function (code) {

    if (typeof cssmin !== "function") {
        if (typeof exports !== "object") {
            return code;
        }
        cssmin = require('cssmin/cssmin').cssmin;
    }

    return cssmin(code);
};





















ModuleBuilder.resolveJsRequires = function (content, buildFile) {

    var r = {
        includes: [],
        excludes: [],
        content: content
    };

    switch (buildFile.dependencySyntax) {
        case "boot":
            r.content = content.replace(/^(\s*)\/[\/\*]\s*#(\w+)\s+(.*)$/gm, function (all, indent, macro, args) {
                switch (macro) {
                    case 'include':
                    case 'import':
                    case 'imports':
                        r.includes.push(args);
                        break;

                    case 'exclude':
                    case 'included':
                        r.excludes.push(args);
                        break;
                    case 'assert':
                        if (buildFile.addAssert)
                            return indent + ModuleBuilder._replaceAssert(args);
                        break;
                    case 'deprected':
                        if (buildFile.addAssert)
                            return indent + 'if(window.console && console.warn) console.warn("' + (args.replace(/\"/g, "\\\"") || "This function is deprected.") + '")';
                        break;
                }

                return all;
            });
            break;

            //case "amd":
            //    content.replace(/define\s*\(\s*(['"])(\w+)\1\s*\)$/g, function (all, indent, macro, args) {
            //        modules.push(args);

            //        return all;
            //    });

            //case "cmd":
            //	content.replace(/require\s*\(\s*(['"])(\w+)\1\s*\)$/g, function (all, indent, macro, args) {
            //		modules.push(args);

            //		return all;
            //	});
            //	break;

            //case "yui":
            //	content.replace(/YUI().use\s*\(\s*(['"])(\w+)\1\s*\)$/g, function (all, indent, macro, args) {
            //		modules.push(args);

            //		return all;
            //	});
            //	break;

            //case "kissy":
            //	content.replace(/KISSY.use\s*\(\s*(['"])(\w+)\1\s*\)$/g, function (all, indent, macro, args) {
            //		modules.push(args);

            //		return all;
            //	});
            //	break;


    }


    return r;
};

ModuleBuilder._replaceAssert = function (args) {

    // args = exp @fun(args): message

    var at = args.indexOf('@'),
		expr = at < 0 ? args : args.substr(0, at),
		defaultMessage = expr,
		message = at > 0 ? args.substr(at + 1) : "Assertion fails";

    // value:type check
    if ((at = /^(.+):\s*(\w+)(\??)\s*$/.exec(expr)) && at[2] in typeAsserts) {
        expr = (at[3] ? at[1] + ' == null || ' : at[1] + ' != null && ') + typeAsserts[at[2]].replace(/\$/g, at[1]);
        defaultMessage = at[1] + ' should be a(an) ' + at[2] + (at[3] ? ' or undefined.' : '.');
    }

    if (message.indexOf(':') < 0) {
        message += ': ' + defaultMessage;
    }

    return 'if(!(' + (expr || 1) + ') && window.console && console.error) console.error("' + message.replace(/\"/g, "\\\"") + '");';
},

ModuleBuilder.parseRelativePath = function (basePath, relativePath) {
    var protocol = /^\w+:\/\/[^\\]*?(\/|$)/.exec(basePath);
    if (protocol) {
        basePath = basePath.substr(protocol[0].length);
    }
    basePath = Path.resolve(Path.dirname(basePath), relativePath).replace(/\\/g, "/");
    return protocol ? protocol[0] + basePath : basePath;
};

ModuleBuilder._concatPath = function (pathA, pathB) {
    return pathB.charAt(0) === '/' ? (/\/$/.test(pathA) ? pathA + pathB.substr(1) : (pathA + pathB)) : (/\/$/.test(pathA) ? pathA + pathB : (pathA + "/" + pathB));
};

ModuleBuilder._excludeBuildFiles = function (buildContext, inputs, callback) {

    var i = 0, me = this;

    function step() {

        if (i < inputs.length) {
            ModuleBuilder.load(ModuleBuilder.parseRelativePath(buildContext.file.path, inputs[i]), function (buildFile) {
                ModuleBuilder.build({

                    file: buildFile,

                    contents: buildContext.contents,

                    start: emptyFn,

                    complete: function (result) {

                        for (var fullPath in result.js) {
                            delete buildContext.js[fullPath];
                        }

                        for (var fullPath in result.css) {
                            delete buildContext.css[fullPath];
                        }

                        for (var fullPath in result.assets) {
                            delete buildContext.assets[fullPath];
                        }

                        step();
                    }

                });
            });

        } else if (callback) {
            callback();
        }

    }


    function emptyFn() {

    }


    step();

};

//#endregion

//#region 产出输出

ModuleBuilder.writeJs = function (result, writer) {

    for (var hasModule in result.js) {

        result.log("正在生成 js 代码...");

        var comment = result.file.prependModuleComments;

        if (comment) {

            if (comment.indexOf("{time}") >= 0) {
                comment = comment.replace("{time}", ModuleBuilder._getNow());
            }

            if (comment.indexOf("{source}") >= 0) {
                comment = comment.replace("{source}", result.file.path || "");
            }

            if (comment.indexOf("{modules}") >= 0) {
                var list = [];
                for (var i in result.js) {
                    list.push("//#included " + result.js[i].path);
                }
                for (var i in result.css) {
                    list.push("//#included " + result.css[i].path);
                }

                list.sort();
                comment = comment.replace("{modules}", list.join(result.file.lineBreak));
            }

            comment = comment.replace(/\r?\n/g, result.file.lineBreak);

            writer.write(comment);
            writer.write(result.file.lineBreak);

        }

        comment = result.file.prependModuleComments;

        if (comment) {
            comment = comment.replace(/\r?\n/g, result.file.lineBreak);
        }

        for (var i in result.js) {
            if (comment) {
                writer.write(comment.replace("{module}", result.js[i].path));
            }

            var content = result.js[i].content;

            if (result.file.compress) {
                content = ModuleBuilder._compressJs(content);
            }

            writer.write(content);
        }

        break;
    }

};

ModuleBuilder.writeCss = function (result, writer) {

    for (var hasModule in result.css) {

        result.log("正在生成 css 代码...");

        var comment = result.file.prependComments;

        if (comment) {

            if (comment.indexOf("{time}") >= 0) {
                comment = comment.replace("{time}", ModuleBuilder._getNow());
            }

            if (comment.indexOf("{source}") >= 0) {
                comment = comment.replace("{source}", result.file.path || "");
            }

            comment = comment.replace("{modules}", "");

            comment = comment.replace(/\r?\n/g, result.file.lineBreak);

            writer.write(comment);
            writer.write(result.file.lineBreak);

        }

        comment = result.file.prependModuleComments;

        if (comment) {
            comment = comment.replace(/\r?\n/g, result.file.lineBreak);
        }

        for (var i in result.css) {
            if (comment) {
                writer.write(result.file.lineBreak);
                writer.write(comment.replace("{module}", result.css[i].path));
                writer.write(result.file.lineBreak);
            }

            var content = result.css[i].content;

            if (result.file.compress) {
                content = ModuleBuilder._compressCss(content);
            }

            writer.write(content);
        }

        break;
    }


};

ModuleBuilder._getNow = function () {
    var d = new Date();
    d = [d.getFullYear(), '/', d.getMonth() + 1, '/', d.getDate(), ' ', d.getHours(), ':', d.getMinutes()];

    if (d[d.length - 1] < 10) {
        d[d.length - 1] = '0' + d[d.length - 1];
    }

    if (d[d.length - 3] < 10) {
        d[d.length - 3] = '0' + d[d.length - 3];
    }

    return d.join('');
};

//#endregion
