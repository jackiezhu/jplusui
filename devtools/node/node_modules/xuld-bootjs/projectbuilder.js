/**
 * @fileOverview 项目打包工具。用于发布整个项目。
 * 发布项目时，只需指定一个文件夹，即可将文件夹内的代码进行压缩、代码合并。
 * @author xuld
 */

var Path = require('path');
var IO = require('utilskit/io');
var Utility = require('./utility');
var ModuleBuilder = require('./modulebuilder');

var ProjectBuilder = exports;

ProjectBuilder.defaultOptions = {

    // 发布的源文件夹。
    from: './',

    // 发布的目标文件夹。
    to: '../build/',

    // 源码统一编码。
    encoding: 'utf-8',

    // 自定义发布重定向规则。
    redirects: [],

    // 是否在生成前清空项目文件夹。
    clearDir: true,

    // 指示各个文件类型的发布方案。
    fileTypes: {
        '.js': {

            // 是否压缩文件。
            minify: true,

            // 默认发布处理逻辑。
            process: function (options, fromPath, toPath, fromName, toName) {
                if (this.minify) {
                    var src = IO.readFile(fromPath, options.encoding);
                    try {
                        src = Utility.compressJs(src);
                    } catch (e) {
                        ProjectBuilder.error('压缩失败：' + e.message);
                        options.errorCount++;
                    }
                    IO.writeFile(toPath, src, options.encoding);
                } else {
                    IO.copyFile(fromPath, toPath);
                }
            }
        },

        '.css': {
            minify: true,
            process: function (options, fromPath, toPath, fromName, toName) {
                if (this.minify) {
                    var src = IO.readFile(fromPath, options.encoding);
                    try {
                        src = Utility.compressCss(src);
                    } catch (e) {
                        ProjectBuilder.error('压缩失败：' + e.message);
                        options.errorCount++;
                    }
                    IO.writeFile(toPath, src, options.encoding);
                } else {
                    IO.copyFile(fromPath, toPath);
                }
            }
        },

        '.html': {
            resolveBootJs: true,
            appendVersionPostfix: true,
            process: function (options, fromPath, toPath, fromName, toName) {

                // 读取 HTML 源码。
                var content = IO.readFile(fromPath, options.encoding);

                // 更新 boot.js 依赖。
                if (this.resolveBootJs) {
                    try {
                        content = ModuleBuilder.parseHtml(content, fromPath);
                    } catch (e) {
                        ProjectBuilder.error('打包 boot.js 失败：' + e.message);
                        options.errorCount++;
                    }
                }

                var versionPostfix = this.appendVersionPostfix && options.versionPostfix || (options.versionPostfix = '_=' + Utility.getNow().replace(/[\/\s:]/g, ""));

                // 更新 href|src 指向。
                content = content.replace(/(href|src)(\s*=\s*(['""]?))([^'""]*)(\3)/gi, function (all, href, q1, q, url, q2) {

                    var path = url.replace(/[#\?].*$/, '');
                    var query = url.substr(path.length);

                    // 不处理绝对路径。
                    if (path.indexOf(':/') < 0) {
                        var newPath = Utility.resolveRelativePath(fromName, path);
                        newPath = ProjectBuilder.redirect(options, newPath);
                        if (newPath) {
                            url = newPath + query;
                        }
                    }

                    if (versionPostfix) {
                        url += (query ? '&' : '?') + versionPostfix;
                    }

                    return href + q1 + url + q2;
                });

                // 压缩代码。
                if (this.minify) {
                    content = Utility.compressHtml(content);
                }

                // 生成 HTML 源码。
                IO.writeFile(toPath, content, options.encoding);

            }
        },

        '.tmp': {

            // 是否忽略本类型的文件。
            ignore: true
        },

        '.ai': {
            ignore: true
        },

        '.psd': {
            ignore: true
        },

        '*': {
            process: function (options, fromPath, toPath, fromName, toName) {
                IO.copyFile(fromPath, toPath);
            }
        }
    }
};

/**
 * 执行项目生成操作。
 * @param {Object} options 生成的配置项。
 */
ProjectBuilder.build = function (options) {

    // 1. 设置默认配置。
    options = Utility.extendIf(options || {}, ProjectBuilder.defaultOptions);
    for (var fileType in ProjectBuilder.defaultOptions.fileTypes) {
        options.fileTypes[fileType] = Utility.extendIf(options.fileTypes[fileType] || {}, ProjectBuilder.defaultOptions.fileTypes[fileType]);
    }

    // 2. 修复配置值。
    options.from = Path.resolve(options.from);
    options.to = Path.resolve(options.to);
    options.errorCount = 0;

    // 3. 开始生成。
    ProjectBuilder.log('开始生成项目...\n\n从：' + options.from + '\n到：' + options.to + '\n\n');

    if (options.clearDir) {
        try {
            IO.clearDir(to);
        } catch (e) {
        }
    }

    var files = IO.getFiles(options.from);
    for (var i = 0; i < files.length; i++) {
        ProjectBuilder.buildFile(options, files[i]);
    }

    // 3. 生成完成。
    if (options.errorCount) {
        ProjectBuilder.log('\n\n从：' + options.from + '\n到：' + options.to + '\n\n项目生成失败：' + options.errorCount + ' 个错误\n');
    } else {
        ProjectBuilder.log('\n\n从：' + options.from + '\n到：' + options.to + '\n\n项目生成成功。\n');
    }

};

ProjectBuilder.buildFile = function (options, from) {
    var to = ProjectBuilder.redirect(options, from);
    if (to === null) {
        ProjectBuilder.log('~ ' + from);
        return null;
    }

    var fileType = options.fileTypes[Path.extname(from)] || options.fileTypes['*'];
    if (fileType.ignore) {
        ProjectBuilder.log('- ' + from);
        return null;
    }

    ProjectBuilder.log('> ' + to);

    if (!fileType.process) {
        fileType = options.fileTypes['*'];
    }

    fileType.process(options, Path.resolve(options.from, from), Path.resolve(options.to, from), from, to);
    return to;
}

/**
 * 确定一个路径发布后的路径。
 */
ProjectBuilder.redirect = function (options, from) {
    for (var i = 0; i < options.redirects.length; i++) {
        var redirectRule = options.redirects[i];

        if (from.match(redirectRule.from)) {
            from = from.replace(redirectRule.from, redirectRule.to);

            if (!redirectRule.continueRedirect) {
                break;
            }

        }

    }

    return from;
};

ProjectBuilder.log = function (message) {
    console.log(message);
};

ProjectBuilder.error = function (message) {
    console.error(message);
};



